<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction &#8212; DataTech 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Data and Computation" href="data.html" />
    <link rel="prev" title="Data Science: Principles and Python" href="../index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-data-scientist">
<h2>The Data Scientist<a class="headerlink" href="#the-data-scientist" title="Permalink to this headline">¶</a></h2>
<p>Congratulations, you were selected by fate to witness the data science revolution.  Like the technological revolutions that came before (e.g., agricultural, industrial, telecommunications), it will have beneficial, destructive, awesome, dreadful, and silly consequences.  At least, this is the popular narrative portrayed in the media, by companies trying to find investors, and by professors trying to gain interest in their courses.  It is commonly reported that governments and corporations are racing to develop artificial intelligence and machine learning, while anticipating that such measures will determine the next winners in their colossal power struggles.  Harnessing these sophisticated tools requires teams of data scientists managing, curating, processing data; visualizing data and interpreting statistics; designing learning machines and evaluating their performance; and inventing new artificial intelligence algorithms.  When faced with this prospect, most of us&#8212;those of us that are not already working as or studying to be data scientists&#8212;are left over-awed, intimidated, and often uninspired.  We endow data science with these (overtly masculine) superlatives despite the fact that it is a poorly understood field still in its infancy.  It will take an entire community of scientists to understand its subtle principles and practices.</p>
<p>One popular misconception is that data science is reserved for only elite computer scientists and mathematicians.  How can I make it in this field if I did not write my first computer program at 8, learn calculus at 14, and survive the cauldron of an elite university.  I would posit an alternative hypothesis: there are no super-geniuses, just people that have a combination of confidence, ability, and opportunity.  If the data science revolution is truly to be a technological revolution, spanning multiple generations and spawning new industries, it will have to be accessible to a broad swath of skilled workers.  As we will see in this book, data science requires probabilistic reasoning, an understanding of basic Computer Science and Statistics, a good grasp of the technologies out there, and lots of common sense.</p>
<p>Another popular misconception is that machine learning is the search for a master algorithm that will solve all data science problems.  (Machine learning is the subfield of data science concerning algorithms that improve their performance by processing data.)  The implication is that all &#8220;lower level&#8221; data scientists will one day suddenly be made obsolete.  This disheartening notion has no historical basis.  In the 1990&#8217;s, machine learning research was dominated by algorithms such as neural networks and support vector machines which are used to classify items based on features from labeled data.  In 1998, the founders of Google, Larry Page and Sergey Brin, developed the PageRank algorithm to rank websites based on popularity and connectedness within the World Wide Web (WWW).  This became the founding technology for the Google search engine, and it has nothing to do with support vector machines and neural networks.  It is not even a classification algorithm.  The PageRank algorithm is based on a thought experiment where you imagine performing a random walk in the WWW, hopping along hyperlinks to see how frequently you land at each webpage.  While they were not alone in thinking of this idea&#8212;Jon Kleinberg introduced the related HITS algorithm in the same year&#8212;PageRank was developed independently of the bulk of research in machine learning because it does not fit into the classification framework.  As of August 2018, Google&#8217;s parent company, Alphabet Inc. has a market cap of 848 Billion USD.</p>
<p>Most machine learning methods are tailored to very specific data types and tasks, and often the challenge is to understand what tools are needed when.  In my machine learning class, often I find that after teaching my students about support vector machines, random forests, neural networks, and boosted decision trees, we are stymied by missingness in real datasets.  Missing data is just one example of a common occurrence that we did not anticipate when we designed most machine learning algorithms.  The topic of missing data alone could consume a Ph.D. thesis or even a career.  The case of missing data is more evidence that in reality a good data scientist can think clearly about a variety of issues and is not just focused on finding the one learning algorithm to rule them all.</p>
<p>To see this alternative narrative play out we only need to look at the state of machine learning research as it actually is.  If we look at the subject areas for the 2018 Proceedings of the Neural Information and Processing Systems (a top machine learning publication) we see that they are primarily delineated by the data modality or machine learning task.  For example, active learning, bandit algorithms, collaborative filtering, online learning, and structured prediction are all different tasks or data types in machine learning.  We are running into more data science problems every day, and for every new algorithm that improves on a pre-existing method, there is another new algorithm that solves a heretofore unsolved problem.  So take heart, there is room for you in this exciting new field.</p>
</div>
<div class="section" id="why-python">
<h2>Why Python?<a class="headerlink" href="#why-python" title="Permalink to this headline">¶</a></h2>
<p>Python was developed in 1991 by Guido van Rossum because the popular procedural languages of the time (perl, C, Fortran, etc.) were deficient for many common tasks.  C (Dennis Ritchie, 1973) is great for writing fast optimized code, but it suffers from flexibility because of the need to declare variables, and the thin layer of abstraction (you are a bit closer to the machine).  Perl (Larry Wall, 1987) is great for writing scripts that interacted with unix, processed strings, and being able to do this quickly with minimal effort.  One common complaint of Perl is that it was very easy to write nearly unreadable code in Perl (aka line garbage), and it is filled with heuristics.  Python is like Perl in that there is sufficient abstraction to write code without thinking too much about memory allocation and type compatibility, but unlike Perl, it emphasizes readibility.  Python and Perl are both interpreted languages, meaning that they come with interpreters that will run code line by line as you execute them, while C is compiled, meaning that you write code and then a program, called a compiler, converts it into machine code (code that the CPU can directly read).</p>
<p>For these reasons, Python&#8217;s popularity has grown, so that now it is the 2nd most popular language after Java.  One advantage of this is that there exist tons of great packages for Python, such as numpy, scipy, matplotlib, etc.  That is why we use Python for data science.  Matlab and C++ are going to be typically faster, but it is often wiser to go out and find a package that already implements what you want to do, so that you don&#8217;t have to code everything from scratch (and it will probably be a much faster implementation).  While most of this course will be about using different packages in Python, you need to learn the basic Python syntax, because inevitably you will need to program basic things by hand.
Another fundamental programming language for the data scientist is R, which has more extensive statistical packages than Python.
R is not as universally used as Python though, and for some things, such as working with unstructured data and text, it is a bit cumbersome.
Ideally, you will be familiar with both languages and will use whichever is more well suited for the task at hand.</p>
</div>
<div class="section" id="installation-and-workflow">
<h2>Installation and Workflow<a class="headerlink" href="#installation-and-workflow" title="Permalink to this headline">¶</a></h2>
<p>Throughout this book, it will be helpful to have access to a unix shell such as bash.
Often this is called the terminal, and the basic idea is that you can enter in commands such as</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ whois google.com
</pre></div>
</div>
<p>and it will run a program, instead of having to click on it through your windows manager and graphical user interfaces (gui).
The command line gives you greater control and more specificity when working with your computer.
The command above, for example, lets you find out that google.com was registered on 15 Sept 1997 in California by Google LLC.
In Mac OS X or Linux, you can open up the terminal and test this out by typing <code class="docutils literal"><span class="pre">echo</span> <span class="pre">$PATH</span></code>.
In windows however you will either need to install a bash shell or use the Ubuntu on Windows subsystem.
For windows, I recommend just installing Anaconda (see below) and using the Anaconda prompt if you need a shell.</p>
<p>Different systems will have different commands available.
For example, <code class="docutils literal"><span class="pre">whois</span></code> was not installed by default on my system and I had to install it first.
On the Linux distribution Ubuntu, I can use the apt package manager as in</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ apt install whois
</pre></div>
</div>
<p>but in Mac OS X, you should use the <code class="docutils literal"><span class="pre">brew</span></code> package manager.
As in all other things, google.com is your friend, if you run into errors or don&#8217;t remember specific commands, just google it and descend down whatever rabbit-hole seems promising.</p>
<div class="section" id="cpython-install">
<h3>CPython install<a class="headerlink" href="#cpython-install" title="Permalink to this headline">¶</a></h3>
<p>When we talk about Python, we are talking about the Python language, but the interpreter is what actually executes the code.
CPython is the most common interpreter, and it is called CPython because it is implemented in C.
Throughout this book, we will be using Python 3, which differs significantly enough from Python 2 that some of the code presented here will not work with the Python 2 interpreter.
There are likely many ways to install the Python 3 CPython interpreter on your system.
If you want to minimize the amount of time that you spend on installation issues&#8212;if you are a student in one of my classes and you are new to installing Python packages&#8212;then I recommend using Anaconda instead of these method because it is easier to maintain the packages and you can install R, jupyter, ipython, and spyder very easily.
Nevertheless, in some instances you may want to install Python directly, so here we go.
<strong>In case you missed it only do the following if you want to have greater control over you own installation, and need to build some things from source.  Otherwise, skip to the Anaconda section.</strong></p>
<p><strong>Ubuntu:</strong> In the Linux distribution Ubuntu, you can install Python 3 on your system with <code class="docutils literal"><span class="pre">$</span> <span class="pre">apt</span> <span class="pre">install</span> <span class="pre">python3</span></code> or installation through the source.
This may not be necessary for your installation because python3 comes installed on Ubuntu by default.
For other Linux distributions, you should first try using your package manager.
You will need to install <code class="docutils literal"><span class="pre">pip</span></code>, <code class="docutils literal"><span class="pre">setuptools</span></code>, and <code class="docutils literal"><span class="pre">virtualenv</span></code>.
To install pip and setuptools (Python package installers)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ wget https://bootstrap.pypa.io/get-pip.py
$ sudo python3 get-pip.py
</pre></div>
</div>
<p>This will install both on your machine, and now the command line tools <code class="docutils literal"><span class="pre">pip3</span></code> and <code class="docutils literal"><span class="pre">easy_install</span></code> should be available.
Next, you will need to install virtualenv which lets you isolate Python environments.
To install run <code class="docutils literal"><span class="pre">$</span> <span class="pre">pip3</span> <span class="pre">install</span> <span class="pre">--user</span> <span class="pre">virtualenv</span></code>.
Skip to the note on <code class="docutils literal"><span class="pre">$PATH</span></code> at the end of the Anaconda section.</p>
<p><strong>Mac OS X:</strong> The version of Python that comes with Mac OS X is a specific Mac build but it is preferred that you do your own install.
If you do not already have it you will need to install Homebrew, which is a package manager for Mac OS X.
In the terminal application run the following,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</pre></div>
</div>
<p>If you have trouble with the brew, visit the <a class="reference external" href="https://brew.sh/">Homebrew webpage</a> .
Now you should be able to run the following: <code class="docutils literal"><span class="pre">$</span> <span class="pre">brew</span> <span class="pre">install</span> <span class="pre">python3</span></code>, which will install Python3.
Homebrew should have installed pip and setuptools for you, so proceed to installing virtualenv with <code class="docutils literal"><span class="pre">$</span> <span class="pre">pip3</span> <span class="pre">install</span> <span class="pre">virtualenv</span></code>.
Skip to the note on <code class="docutils literal"><span class="pre">$PATH</span></code> at the end of the Anaconda section.</p>
<p><strong>Windows:</strong> Use Anaconda.</p>
<p>On all these systems you will want to install the scipy stack via the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pip3</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span> <span class="n">numpy</span> <span class="n">scipy</span> <span class="n">matplotlib</span> <span class="n">ipython</span> <span class="n">jupyter</span> <span class="n">pandas</span>
</pre></div>
</div>
<p><strong>Wheels:</strong> Generally, you will use <code class="docutils literal"><span class="pre">$</span> <span class="pre">python3</span></code> and <code class="docutils literal"><span class="pre">$</span> <span class="pre">pip3</span></code> for your interpreter and package installer.
Many Python packages, such as SciPy, use C extensions.
As of the latest version of pip one could install scipy with the command <code class="docutils literal"><span class="pre">$pip3</span> <span class="pre">install</span> <span class="pre">scipy</span></code>, but you may encounter build issues in which case you can install via wheels, which allow pip to install precompiled packages.
This is especially common in Windows, and you can find your wheel and some instructions here: <a class="reference external" href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy">Unofficial Windows Binaries for Python Extension Packages</a> .</p>
</div>
<div class="section" id="anaconda">
<h3>Anaconda<a class="headerlink" href="#anaconda" title="Permalink to this headline">¶</a></h3>
<p>Anaconda is a Python distribution that comes with its own Package installer <code class="docutils literal"><span class="pre">conda</span></code>.
To install you should go to the <a class="reference external" href="https://www.anaconda.com/download/">anaconda.org download page</a> and choose your operating system.
It also comes with the scipy stack, jupyter, ipython, and spyder.
You can also use it to install R through the r-essentials package, and this will allow you to run an R kernel in jupyter.
Julia is another language that you may be interested in, with the new Julia 1.0 version you may find that you can write much faster scripts if you are coding something from scratch.
You can also install julia with conda.</p>
<p>While there is a Desktop gui for Anaconda, I find that you have better control from command line.
If you are a Linux or Mac user the terminal is sufficient, but for Windows you probably do not have a shell that you use often.
In Windows, Anaconda ships with a bash shell from which you can run all the necessary commands.
Just search for the anaconda prompt and then pin it to your desktop.
From here you should be able to run the commands <code class="docutils literal"><span class="pre">$</span> <span class="pre">python</span></code>, <code class="docutils literal"><span class="pre">$</span> <span class="pre">ipython</span></code>, <code class="docutils literal"><span class="pre">$</span> <span class="pre">jupyter</span> <span class="pre">notebook</span></code>.
In fact, <code class="docutils literal"><span class="pre">$</span> <span class="pre">ssh</span></code> is also available here, so it should also work for remote computing.</p>
<p>You may want to start with updating conda: <code class="docutils literal"><span class="pre">$</span> <span class="pre">conda</span> <span class="pre">update</span> <span class="pre">conda</span></code>.
In order to see what packages you have installed in conda run <code class="docutils literal"><span class="pre">$</span> <span class="pre">conda</span> <span class="pre">list</span></code> and then you should see a list of packages with their versions, for example,</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">numpy</span> <span class="mf">1.14</span><span class="o">.</span><span class="mi">0</span> <span class="n">py36h4a99626_1</span>
</pre></div>
</div>
<p>which tells us that numpy is installed at version 1.14.0.
You should see numpy, scipy, matplotlib, ipython, jupyter, pandas.
If you do not then install them with <code class="docutils literal"><span class="pre">$</span> <span class="pre">conda</span> <span class="pre">install</span> <span class="pre">PACKAGENAME</span></code> where <code class="docutils literal"><span class="pre">PACKAGENAME</span></code> is replaced with your package.
Think of conda as replacing pip, except that you can also use conda to install pip, and then use pip nested within conda.
You might do this if you want to use a package that is not common enough for conda to have it in a channel.
You can also update packages with <code class="docutils literal"><span class="pre">$</span> <span class="pre">conda</span> <span class="pre">update</span> <span class="pre">PACKAGENAME</span></code>, and for other conda commands see <a class="reference external" href="https://conda.io/docs/_downloads/conda-cheatsheet.pdf">this cheetsheet</a> .</p>
<p><strong>$PATH:</strong> Suppose that you went to all of the trouble that I outlined above, either installing CPython or Anaconda, but then when you type in <code class="docutils literal"><span class="pre">$</span> <span class="pre">python</span></code> or <code class="docutils literal"><span class="pre">$</span> <span class="pre">python3</span></code> it does not exist or it is the wrong version.  For example, if this gives you the following prompt:</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">Python</span> <span class="mf">2.7</span><span class="o">.</span><span class="mi">14</span> <span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">Sep</span> <span class="mi">23</span> <span class="mi">2017</span><span class="p">,</span> <span class="mi">22</span><span class="p">:</span><span class="mi">06</span><span class="p">:</span><span class="mi">14</span><span class="p">)</span>
<span class="p">[</span><span class="n">GCC</span> <span class="mf">7.2</span><span class="o">.</span><span class="mi">0</span><span class="p">]</span> <span class="n">on</span> <span class="n">linux2</span>
<span class="n">Type</span> <span class="s2">&quot;help&quot;</span><span class="p">,</span> <span class="s2">&quot;copyright&quot;</span><span class="p">,</span> <span class="s2">&quot;credits&quot;</span> <span class="ow">or</span> <span class="s2">&quot;license&quot;</span> <span class="k">for</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>this means that it is using Python 2 still (see the Python 2.7.14).  If <code class="docutils literal"><span class="pre">$</span> <span class="pre">python3</span></code> gives you a Python 3 prompt, then this is fine just be aware that you will need to use <code class="docutils literal"><span class="pre">$</span> <span class="pre">python3</span></code> and <code class="docutils literal"><span class="pre">$</span> <span class="pre">pip3</span></code> every time that we write <code class="docutils literal"><span class="pre">$</span> <span class="pre">python</span></code> for example.
If <code class="docutils literal"><span class="pre">python3</span></code> does not work, what is happening is that the shell does not know where your Python 3 installation is (for example in Ubuntu by install has a symbolic link in <code class="docutils literal"><span class="pre">/usr/bin</span></code>).
You first have to locate your installation, which will depend on your method.
If it is Anaconda then this is going to be in the Anaconda install directory (On my windows machine this is at <code class="docutils literal"><span class="pre">C:\Users\James</span> <span class="pre">Sharpnack\Anaconda3</span></code>).
In Linux, open your <code class="docutils literal"><span class="pre">~/.profile</span></code> file with a text editor such as emacs or vi and add a line</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span><span class="n">PATH</span><span class="o">=</span><span class="s2">&quot;PATH_TO_PYTHON:$PATH&quot;</span>
</pre></div>
</div>
<p>where PATH_TO_PYTHON is replaced with that path.
In Mac OS X edit the file <code class="docutils literal"><span class="pre">~/.bash_profile</span></code> and add the line</p>
<div class="code bash highlight-default"><div class="highlight"><pre><span></span>export PATH=PATH_TO_PYTHON:$PATH
</pre></div>
</div>
<p>which does the same thing.
Then run this with <code class="docutils literal"><span class="pre">$</span> <span class="pre">source</span> <span class="pre">~/.profile</span></code> (or <code class="docutils literal"><span class="pre">.bash_profile</span></code> for Mac).
In Windows, you can edit the path variable by using the Environment Variables in the Control Panel.
Just search in Windows 8 for &#8220;environment variables&#8221; and it should come up.
You can edit the Path variable there by clicking &#8220;Path&#8221; and &#8220;Edit&#8221;.</p>
</div>
<div class="section" id="text-editors-and-ides">
<h3>Text editors and IDEs<a class="headerlink" href="#text-editors-and-ides" title="Permalink to this headline">¶</a></h3>
<p>Files on your computer are just a bunch of bytes (strings of 0&#8217;s and 1&#8217;s) on your drive. A plain text editor reads these as characters via ASCII, which is a dictionary that converts bytes to characters (like how Ribosomes convert RNA base pairs to amino acids). So you can start a new file using an editor like emacs, vi, or notepad, and write something there like &#8220;Hello world.&#8221; and then save it as &#8220;hello.txt&#8221; or &#8220;hello&#8221; or whatever. Then it writes the bytes that those characters correspond to on your drive. If you do the same thing in Microsoft Word and save it as a Word file, then Word converts it to a different set of bytes and this process is proprietary (it is legally protected by licenses like the recipe for CocaCola). If you open a Word document in emacs it will look like 320317^Q340241261^Z341^&#64;^&#64;^&#64;^&#64;^&#64;^&#64;^&#64;^&#64; which is not very helpful.</p>
<p>One way to write code is to just select a text editor that you like and stick with it for all of your coding needs. Common choices are emacs, vim, sublime, notepad++, atom, etc. All of these have syntax highlighting, but you may need to do some work to enable it depending on your install. The most universal editors are vim and emacs, and they have their own hotkeys and interfaces.
For remote computing it is often nice to already be familiar with vim (or emacs).
This is because these are command line text editors, and can be run entirely in the terminal.
(Although, they both also have graphical user interface (GUI) extensions.)
The following is a list of recommended text editors:</p>
<ul class="simple">
<li>Vim: an open source text editor that is preinstalled on all operating systems other than Windows; has a terminal interface; best for remote computing; syntax highlighting for Python</li>
<li>Emacs: open source text editor with terminal interface; may have to install on server (with <code class="docutils literal"><span class="pre">apt</span> <span class="pre">install</span> <span class="pre">emacs</span></code> for example) for remote computing; syntax highlighting for Python</li>
<li>Atom: open source GUI for text editing; good GitHub integration</li>
<li>Sublime Text: open source GUI for text editing; written in Python with great packages</li>
</ul>
<p>The simplest way to write and run Python scripts is to edit a file, for example, run in terminal <code class="docutils literal"><span class="pre">$</span> <span class="pre">emacs</span> <span class="pre">text.py</span></code> and enter</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>

<span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</pre></div>
</div>
<p>After saving and exiting (in emacs Ctrl-X Ctrl-S Ctrl-X Ctrl-C) then run the script with <code class="docutils literal"><span class="pre">$</span> <span class="pre">python</span> <span class="pre">test.py</span></code>.
This printed the contents of my current directory,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">perceptron</span><span class="o">.</span><span class="n">py</span>
<span class="n">scrabble</span><span class="o">.</span><span class="n">py</span>
<span class="n">test</span><span class="o">.</span><span class="n">py</span>
<span class="n">proc_rst</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Because Python is interpreted, we are able to run the above script line by line in the Python shell.
When we run <code class="docutils literal"><span class="pre">$</span> <span class="pre">python</span></code> we get a prompt that we can use to run lines such as <code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span> <span class="pre">import</span> <span class="pre">os;</span> <span class="pre">os.listdir()</span></code> which will output the contents of the directory as well.
You can use the Python shell as a sophisticated calculator, as in <code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span> <span class="pre">5003.38</span> <span class="pre">+</span> <span class="pre">134.56</span> <span class="pre">-</span> <span class="pre">2500</span></code>.
This works because a just-in-time (JIT) compiler is running in the background, and it compiles each line or function when it needs to.
Typically, the downside to this flexibility is that the code you write in Python is slower than if we had written it in C.</p>
<p>Interactive development environments (IDE) are development tools with Python interpreters and other tools like tab completion (when you hit Tab it auto-completes the code snippet).
IPython is an IDE that acts like a Python shell and has more extensive features than the native Python shell.
Conda comes with IPython or you can install with pip as in <code class="docutils literal"><span class="pre">$</span> <span class="pre">pip</span> <span class="pre">install</span> <span class="pre">ipython</span></code>.
IPython has magic commands that are not part of the Python language, and they are prepended with % as in <code class="docutils literal"><span class="pre">%time</span></code> (we will use this magic command for profiling in the next Chapter).
Often I will use ipython to test out code snippets and then use the magic command <code class="docutils literal"><span class="pre">%save</span> <span class="pre">1-30</span> <span class="pre">temp.py</span></code> to write lines 1 through 30 from IPython to a temporary file then move these to a module (a Python file) that I am working on.
Then using the <code class="docutils literal"><span class="pre">%run</span></code> magic command I run the module to import the functions that I have just written.
In this way, I have my favorite editor, emacs, open with the module that I am working on and the temporary code file from IPython, alongside IPython for testing and debugging the code.
You can find a complete tutorial of IPython <a class="reference external" href="https://ipython.readthedocs.io/en/stable/interactive/tutorial.html">in the ipython readthedocs</a> .</p>
<p>All of the editors mentioned above have a Python extension that allow you to have a Python prompt in the editor.
This can expedite the process of copying code from IPython to the editor, although depending on the type of script, this may not be that important.
In vim and emacs, the Python extension is called python-mode.
Conda also has an IDE, called spyder, that is well suited to data science applications.
If you want to use spyder (which I would recommend if you don&#8217;t want to use a text editor with IPython), then you should open a terminal or shell, and run <cite>$ conda install spyder</cite>.
PyCharm is another popular IDE for Python, and it <a class="reference external" href="https://www.jetbrains.com/pycharm/">can be found on the JetBrains website</a>.</p>
</div>
<div class="section" id="jupyter">
<h3>Jupyter<a class="headerlink" href="#jupyter" title="Permalink to this headline">¶</a></h3>
<p>When you use IPython at the command line, it is running the IPython kernel in the background.
The kernel is a process that runs your code and does things like completing code and running magic functions.
Jupyter is an application that communicates with the IPython kernel but provides a sophisticated interface that runs in your web browser.
If you are using conda you probably already have jupyter installed.
If you run <code class="docutils literal"><span class="pre">$</span> <span class="pre">jupyter</span> <span class="pre">notebook</span></code> then it should open a browser tab and you should see the notebook dashboard.  This has files in you current directory which you can navigate around in.
Jupyter is an application for working in IPython notebook files, which have extensions .ipynb.
These are json files (we will see JSON return in a later chapter) that not only saves the code that you have run, but also the output and markdown around the code.</p>
<p>Jupyter is well suited for presenting results of an analysis, and is not that well suited for time intensive scientific computing.
If I am working with a moderately sized dataset, and am doing exploratory data analysis, then I will often use Jupyter.
More often I will develop a module for computationally intensive processing of a dataset using the text editor and IPython.
I&#8217;ll use the module that I have written to process the dataset, which typically will output summary statistics, smaller resulting datasets, and results of analyses.
Then I load these into jupyter and describe and document the analysis and results with markdown and visualizations.
A good rule of thumb is that there should be no cells in your notebook that take more than 30 seconds to run, and most cells should be nearly instantaneous.
If you have something that is taking a long time to run then separate it into a module and run it in the command line (perhaps on a server).</p>
<p>In the left-hand corner of the dashboard, you can click new and select the Python 3 interpreter.  This will open a notebook, which you can rename.
The notebook consists of cells that you can write code in and run via the IPython kernel.
When you are working with a cell, you can either be in command mode or edit mode.
In command mode, you can run the cell, move it around within the notebook, change the cell type to markdown etc.
You can get to edit mode by hitting Enter over a cell.
In edit mode, you are editing the contents, and still have access to IPython tools like tab completion.
You can run the cell with Ctrl-Enter or Shift-Enter (to move down a cell also), and can exit to command mode with Esc.
It helps to know more hotkeys, and you can find them <a class="reference external" href="https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/">in this tutorial</a> .</p>
<p>One very nice thing about Jupyter is that you can add markdown cells around the code cells to document the code, interpret results, and provide background.
Markdown is a descriptive markup language that allows for easy structural formatting of text.
For example a cell in markdown mode with</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">### Header</span>
</pre></div>
</div>
<p>will produce a header like</p>
<div class="section" id="header">
<h4>Header<a class="headerlink" href="#header" title="Permalink to this headline">¶</a></h4>
<p>You can easily add lists, tables, links, code snippets, quotes, embed HTML and images, and equations.
You can find <a class="reference external" href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">a markdown cheatsheet here</a> .
Equations are in LaTeX, for example $\alpha$ is interpretted as <span class="math">\(\alpha\)</span>.
LaTeX is another markup language that is used for mathematical writing.
You can write full equations and inline equations using \[ and $ respectively.
For a cheatsheet on LaTeX you can look at <a class="reference external" href="https://www.nyu.edu/projects/beber/files/Chang_LaTeX_sheet.pdf">this file</a> .</p>
</div>
</div>
<div class="section" id="git-and-versioning-systems">
<h3>Git and Versioning Systems<a class="headerlink" href="#git-and-versioning-systems" title="Permalink to this headline">¶</a></h3>
<p>Git is an open source software (code that is free to use and develop by anyone) that provides version control. Imagine that you are working with team of people on the same file, say you all have access to the same Dropbox directory. You could all change the same file, but then when any of you syncs your changes then it will overwrite the other changes. You could set times to edit, such as Don edits from 10am-12pm, Peggy edits from 12pm-2pm, and Joan edits from 2pm-4pm. Or you could keep versions of files by changing the file name, so when I edit lucky_strikes_v3.py then I edit and save as lucky_strikes_v4.py. These all seem cumbersome, and versioning systems provide a better way. Git (and other versioning systems) provides the following features:</p>
<ul class="simple">
<li>A history of changes to files serving as a backup.</li>
<li>Developers can work concurrently and then with the help of git merge their changes.</li>
<li>Tracing what changes were made by whom when.</li>
</ul>
<p>In any directory you can run <code class="docutils literal"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">init</span></code> and then it will add a .git folder at that directory.
This is the root directory for your new repository and it will keep records of the files that are being tracked.
Typically, you will want to track files that are human readable code files, git is not really made for storing data and other large files that you will not be editting by hand.
If you have a file, say module.py that you want to track you add it with <code class="docutils literal"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">add</span> <span class="pre">module.py</span></code> and now the current version is staged for commit.
You can see the status of files in the directory with <code class="docutils literal"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">status</span></code>.
Once you are ready to commit the changes use <code class="docutils literal"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">commit</span> <span class="pre">-m</span> <span class="pre">&quot;some</span> <span class="pre">message&quot;</span></code> with a message that describes the commit in the quotes.
Then if you have a remote repository set up you can push these changes to the remote repository with <code class="docutils literal"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">push</span> <span class="pre">origin</span> <span class="pre">remote</span></code>.</p>
<p>Why do all of this?
As we have mentioned, it is mostly for collaboration.
If someone else pushed their changes to the remote repository first, then you will get an error telling you to pull these changes before you push your own.
Then you will rull <code class="docutils literal"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">pull</span></code>, in which case, it will update your local repository.
You with then get a notification that a conflict has occurred and where, in which case you will have to go into that file and resolve the conflict.
Typically, there is some update that your colleague has done that you need to make your code consistent with.
The file that is in conflict will have diff annotation, like &gt;&gt;&gt;&gt; indicating where the different versions conflict.
Once the file is to your liking then you should git add the file, commit again, and push.</p>
<p>Git is a distributed versioning system meaning that there is no distinction between a server and a client repository&#8212;all repositories are created equal.
Github is a company that provides git repositories on their computers that you can use as your remote servers.
You can set up an account on <a class="reference external" href="http://github.com">github.com</a> and then start your own repository.
It will then show you how to initialize the repository on your computer and then you can add collaborations in the Settings tab.
The collaborators can clone your repository with <code class="docutils literal"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">clone</span> <span class="pre">https://github.com/username/reponame</span></code> and the start working with it locally.</p>
<p>The following are some resources for learning to use git:</p>
<ul class="simple">
<li><a class="reference external" href="https://www.atlassian.com/git/tutorials">Git tutorials by Atlassian</a></li>
<li><a class="reference external" href="https://www.git-tower.com/blog/git-cheat-sheet/">Git command cheat sheet</a></li>
<li><a class="reference external" href="https://try.github.io/">GitHub git tutorial</a></li>
</ul>
</div>
</div>
<div class="section" id="this-book">
<h2>This Book<a class="headerlink" href="#this-book" title="Permalink to this headline">¶</a></h2>
<p>In this book we will view data science as a rich field that requires a variety of technologies, a broad set of principles, and a diverse community of scientists.  One byproduct of our holistic approach is that we will move between subject areas such as computer science, statistics, and mathematics.  While this is disconcerting to many students, this structure is a byproduct of recognizing that data science is a broader field that encompasses several subfields.  This book is one attempt to provide a common core of data science principles and technologies.  We will attempt to achieve some level of data science literacy, and the ultimate goal is to help you become a practicing data scientist.
This book makes for a poor reference, and should be read in sequence, there are many reference books out there for the Python language and data science modules.
This book is intended for advanced undergraduate students and first year graduate students that have taken some computer science and statistics courses including having:</p>
<ul class="simple">
<li>Taken a course or two in probability and statistics.  This means understanding random variables and their distributions, basic statistics, sampling distribution, confidence intervals, measures of association, hypothesis testing, and multiple linear regression.  When possible I will attempt to review these concepts, but this book may be difficult without a prior introduction to these concepts.  I recommend that you be familiar with the material in a book such as <a class="reference internal" href="#stats" id="id1">[stats]</a></li>
<li>Have some experience with a sequential programming languages such as Python, R, C, or Java.  We will spend a very short amount of time learning the basic syntax of the Python programming language, and will move to more advanced topics such as object oriented programming very quickly.  For a more rudimentary and in depth introduction to Python you can go through the <a class="reference external" href="http://heather.cs.ucdavis.edu/~matloff/Python/PLN/FastLanePython.pdf">material in this Python tutorial</a> as you go through this book.</li>
<li>Have a working knowledge of linear algebra such as matrix multiplication, inner products, etc.  You will not be required to recall abstract linear algebra, such as facts about linear operators on a Hilbert space, and for the most part, it is sufficient to think of a matrix as an array.  I recommend you be familiar with the topics in <a class="reference external" href="https://www.math.ucdavis.edu/~linear/">this free online textbook</a> .</li>
</ul>
<p>Throughout the book we will take the perspective that there is some problem that you want to solve, and data is out there to help you solve it.  You have to extract and process the data and successfully complete the task with any and all tools at your disposal.  This book is intended to not only provide you with the tools necessary, but to also give you the conceptual framework to understand when to use which tools and why you are using them.</p>
<table class="docutils citation" frame="void" id="stats" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[stats]</a></td><td>De Veaux, Richard D., et al. &#8220;Stats: data and models&#8221;. Boston: Pearson/Addison Wesley, 2005.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction</a><ul>
<li><a class="reference internal" href="#the-data-scientist">The Data Scientist</a></li>
<li><a class="reference internal" href="#why-python">Why Python?</a></li>
<li><a class="reference internal" href="#installation-and-workflow">Installation and Workflow</a><ul>
<li><a class="reference internal" href="#cpython-install">CPython install</a></li>
<li><a class="reference internal" href="#anaconda">Anaconda</a></li>
<li><a class="reference internal" href="#text-editors-and-ides">Text editors and IDEs</a></li>
<li><a class="reference internal" href="#jupyter">Jupyter</a><ul>
<li><a class="reference internal" href="#header">Header</a></li>
</ul>
</li>
<li><a class="reference internal" href="#git-and-versioning-systems">Git and Versioning Systems</a></li>
</ul>
</li>
<li><a class="reference internal" href="#this-book">This Book</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../index.html" title="previous chapter">Data Science: Principles and Python</a></li>
      <li>Next: <a href="data.html" title="next chapter">Data and Computation</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/unit1/intro.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, James Sharpnack.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../_sources/unit1/intro.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>