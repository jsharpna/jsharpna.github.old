Introduction to Python
=======================

  "Some quote" -Hamlet

Why Python?
-----------

Python was developed in 1991 by Guido van Rossum because the popular procedural languages of the time (perl, C, Fortran, etc.) were deficient for many common tasks.  C (Dennis Ritchie, 1973) is great for writing fast optimized code, but it suffers from flexibility because of the need to declare variables, and the thin layer of abstraction (you are a bit closer to the machine).  Perl (Larry Wall, 1987) is great for writing scripts that interacted with unix, processed strings, and being able to do this quickly with minimal effort.  One common complaint of Perl is that it was very easy to write nearly unreadable code in Perl (aka line garbage), and it is filled with heuristics.  Python is like Perl in that there is sufficient abstraction to write code without thinking too much about memory allocation and type compatibility, but unlike Perl, it emphasizes readibility.  Python and Perl are both interpreted languages, meaning that they come with interpreters that will run code line by line as you execute them, while C is compiled, meaning that you write code and then a program, called a compiler, converts it into machine code (code that the CPU can directly read).

For these reasons, Python's popularity has grown, so that now it is the 2nd most popular language after Java.  One advantage of this is that there exist tons of great packages for Python, such as numpy, scipy, matplotlib, etc.  That is why we use Python for data science.  Matlab and C++ are going to be typically faster, but it is often wiser to go out and find a package that already implements what you want to do, so that you don't have to code everything from scratch (and it will probably be a much faster implementation).  While most of this course will be about using different packages in python, you need to learn the basic python syntax, because inevitably you will need to program basic things by hand.
Another fundamental programming language for the data scientist is R, which has more extensive statistical packages than Python.
R is not as universally used as Python though, and for some things, such as working with unstructured data and text, it is a bit cumbersome.
Ideally, you will be familiar with both languages and will use whichever is more well suited for the task at hand.

Data in Python
-------------------

In programming languages, a variable refers to a location in memory for a datum (a single number) and the name that we use to identify this location in our code.
In Python, we might initialize a variables by :code:`x=8` which writes the integer 8 to a block in memory and x now references this location.
This differs from the idea of a random variable from probability---x doesn't necessarily have an associated probability distribution---and whenever possible we use the phrase random variable to dilineate them.
Data is anything that we can record and process to extract information, and consequently, we will consider all variables to reference data.
This liberal understanding of data can be befuddling at first.
How can we think of :code:`name = "Herbert Hoover"` as a datum?

Consider the first 15 rows of the following dataframe (a table of data).
The full table contains the length in number of words of the state of the union addresses for each U.S. president [Pres]_.

.. csv-table:: State of the Union Length
   :file: data/state_of_union.csv
   :widths: 30, 30, 30
   :header-rows: 1

Now it makes sense that "Herbert Hoover" is a datum, since it is an element of this dataframe.
We can even think of probability distributions over the name variable since we can think of randomly sampling the rows of this table, making this a random variable in some contexts.
Data can be webpages, images, earnings reports, religious scripture, etc.

Python has built-in variable types that for the most part can be categorized into numeric types, sequences, mappings, classes, instances, and exceptions. 
*Numeric types* include booleans (True and False), integers, floats, and complex. 
*Sequences* include strings, lists, and tuples, while *mappings* are dictionaries.
*Exceptions* are how errors are handled (unless they are syntax errors).
*Classes and instances* enable object-oriented programming in Python: classes are custom types that you can specify in code, while instances are specific variables with that class.
We will not go into all of the details of the python language syntax, but I will highlight some useful tools from the standard library, pythonic concepts, and how these relate to data science.

The words column in the table above contains all integers.
In order to work with one at a time, we could of course define specific variables:

.. code-block:: python
   :caption: average.py
   :name: average.py

   word1 = 1089
   word2 = 1401
   average = (word1 + word2) / 2
   print(average)
   
Then if I run :code:`$ python average.py` in the command line it would output :code:`1245.0`.
What happened is that we saved two integers and averaged them.
Two of our numerical types, integers and floats, appear in the code above; :code:`word1, word2` are integers and :code:`average` will be a float.
This is because in Python 3, integer division (/) always outputs a float type, hence the decimal place in the output.
You can use the operator // for integer division that outputs the rounded down division as in :code:`(word1 + word2) // 2`.
There are many other common operators for the numerical and Boolean types, if you are not familiar with them you can consult https://docs.python.org/3/library/stdtypes.html.

Unlike C or Java, Python is *dynamically typed*, which means that we do not pre-specify that :code:`average` will be a float and Python has to figure this out on the fly.
This is what the just-in-time (JIT) compilation does, it figures out that the computer needs to allocate memory for a float just in time.
The JIT compiler makes it so that we can use python interactively instead of writing separate code and running it from command line like we did for average.py.

We used the python interpreter to run the code in the file, average.py, but we can use python in interactive mode.
I could run each of these lines in ipython, which is effectively using python as a calculator.
This code can only be used to average two numbers unfortunately, so let's write a script that can average a list of data.
Running :code:`$ ipython`, we get a prompt that we can type lines of python code into and get the output in real time:

.. ipython::

   In [1]: words = [1089, 1401, 2302,'NA',2101, 1968, 2918, 1989, 2871]

   In [2]: def average(word_list):
      ...:     """Average a list"""
      ...:     csum = 0
      ...:     num  = 0
      ...:     for wlen in word_list:
      ...:         if type(wlen) == int:
      ...:             csum += wlen
      ...:             num += 1
      ...:     return csum / num
      ...: 

   In [3]: average(words)
   Out[3]: 2079.875

It is cumbersome to maintain an new variable for each datapoint, which is why we use list and arrays in python. 
The first line defines the `words` list, which contains the state of union address lengths for Washington.
Lists are good containers for a repeated variable because we can modify the length, append elements, and select subsets of data (called slicing).
Above, we also threw a curve-ball by adding the :code:`'NA'` string in the list.  
Lists can have variables of any type in them, and mixed type, which makes them very flexible.
It is common in real data to have missing data encoded as strings such as this, or as anomalous values like :code:`999` (This is bad practice, but you may have to deal with it none-the-less).
As a solution, we decided to catch any instance of a non-integer and not include it in the sum.

In the above code, we also saw the use of :code:`def, for, if, return`.
These are standard in sequential programming, and if you need an introduction for logic, control flow, and functions you can skim through https://docs.python.org/3/tutorial/controlflow.html.

Tuples are another form of sequence and they are wrapped in parentheses (), as opposed to brackets [] for lists.
The tuple is an example of an *immutable* variable in Python, which means that the variable does not allow modification after its definition.
So if we attempt to modify the 2nd entry,

.. ipython::

   In [1]: row = ("January 8, 1790","George Washington",1089)

   In [2]: row[1] = "G. Washington"
   ---------------------------------------------------------------------------
   TypeError                                 Traceback (most recent call last)
   <ipython-input-2-144cd323ed29> in <module>()
   ----> 1 row[1] = "G. Washington"

   TypeError: 'tuple' object does not support item assignment

a TypeError is thrown.  Nevertheless, :code:`("January 8, 1790","George Washington",1089)` is a good use of a tuple, because these variables belong together as the record---a row---in a data table.  
Generally, you should think of tuples as records and lists as repeated variables.

Tuples are also support an idiom called tuple unpacking:

.. ipython::

   In [1]: x, y = 1, 2

   In [2]: y, x = x, y

   In [3]: r, (x, y) = (x**2 + y**2)**0.5, (y, x)

   In [4]: print(x, y, r)
   1 2 2.23606797749979

The line [1] made it so that we could define the variables x and y in the same line.
The only requirement was that the right hand side of the equation was a tuple of the same length.
The line [2] shows that you can use this idiom to swap values (this would normally take three lines).
[3] shows that we can apply this to nested tuples, which can be useful if a function returns this type of data.
Did you predict the output of [4]?

Strings are sequences of text and are immutable as well.
We have already seen instances such as :code:`"George Washington"`.
Strings support concatenation with the operator +, and repetition with the operation \*.
The fact that these operators are defined differently for strings as they are for integers and floats is called *operator overloading*.
You should be familiar with the following string methods: :code:`join, strip, split, lower`.
You can find these and other string methods in https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str.

Iteration in Python
----------------------------------------

Python is well suited for use in machine learning because of the general way in which iteration is handled.
To provide some background, we will introduce *supervised learning*.
A supervised learner is any algorithm that takes training data of the form :math:`x_i \in \mathbb R^p, y_i \in \mathbb R, i=1,\ldots,n` and fits a predictor, which is a callable that predicts :math:`y` from a new datapoint, or a test point, :math:`\hat f(x)`. 
The random variables :math:`X,Y` are called the predictor and response variables respectively, and we will assume that the X variables are p dimensional.

For example, we may want to predict if 

Linear regression is an example of a supervised learner such that 

.. math::

   \hat f(x) = \sum_{j = 1}^p \hat \beta_j x_j

In machine learning, we call a method *online* if it will take streaming training data, where the data

.. [Pres] Gerhard Peters,The American Presidency Project [online]. Santa Barbara, CA: University of California (hosted), Gerhard Peters (database). Available from World Wide Web: http://www.presidency.ucsb.edu/inaugurals_words.php.
